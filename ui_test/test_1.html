<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Scaled Video + Aligned Canvas</title>
<style>
  #container { position: relative; display: inline-block; }
  #video, #overlay { position: absolute; top: 0; left: 0; }
  #overlay { pointer-events: none; }
</style>
</head>
<body>

<div id="container">
  <video id="video" muted autoplay loop playsinline>
    <source src="e94ed459-6fef-43ef-926f-c06739908317.mp4" type="video/mp4">
  </video>
  <canvas id="overlay"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
<script>
const video   = document.getElementById('video');
const canvas  = document.getElementById('overlay');
const ctx     = canvas.getContext('2d');

const FPS = 30;                 // frame rate your YAML indices use
const ORIGINAL_W = 1920;        // source coordinate space (for YAML)
const ORIGINAL_H = 1080;

// Make the video smaller while keeping canvas aligned:
const TARGET_WIDTH_PX = 800;    // <-- change this to scale the on-page size

const SKELETON_PAIRS = [
  ['ankle', 'knee'],
  ['knee', 'hip'],
  ['hip', 'shoulder'],
  ['shoulder', 'ear'],
  ['shoulder', 'elbow'],
  ['elbow', 'wrist'],
  ['wrist', 'hand']
];

let landmarks = {};

fetch('landmarks.yaml')
  .then(r => r.text())
  .then(text => {
    landmarks = jsyaml.load(text) || {};
    if (video.readyState >= 1) init();
    else video.addEventListener('loadedmetadata', init, { once: true });
  });

function init() {
  // Set the displayed size of the video; keep aspect ratio with height:auto
  // Once metadata is available, we know natural size to compute height.
  const scale = TARGET_WIDTH_PX / (video.videoWidth || TARGET_WIDTH_PX);
  video.style.width  = TARGET_WIDTH_PX + 'px';
  video.style.height = 'auto';

  // Match canvas CSS size to videoâ€™s displayed size; also match its bitmap size
  sizeCanvasToVideo();

  // Keep them in sync if layout changes
  const ro = new ResizeObserver(sizeCanvasToVideo);
  ro.observe(video);

  requestAnimationFrame(renderLoop);
}

function sizeCanvasToVideo() {
  // CSS size (what you see)
  const w = Math.max(1, video.clientWidth);
  const h = Math.max(1, video.clientHeight);

  canvas.style.width  = w + 'px';
  canvas.style.height = h + 'px';

  // Bitmap size (for crisp drawing)
  canvas.width  = w;
  canvas.height = h;
}

function renderLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const frameIndex = Math.round(video.currentTime * FPS);
  const points = landmarks[frameIndex];
  if (points) drawSkeleton(points);

  requestAnimationFrame(renderLoop);
}

function drawSkeleton(points) {
  const scaleX = canvas.width  / ORIGINAL_W;
  const scaleY = canvas.height / ORIGINAL_H;

  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  ctx.fillStyle = 'blue';

  for (const [a, b] of SKELETON_PAIRS) {
    const p1 = points[a], p2 = points[b];
    if (!p1 || !p2) continue;
    ctx.beginPath();
    ctx.moveTo(p1.x * scaleX, p1.y * scaleY);
    ctx.lineTo(p2.x * scaleX, p2.y * scaleY);
    ctx.stroke();
  }

  for (const k in points) {
    const { x, y } = points[k];
    ctx.beginPath();
    ctx.arc(x * scaleX, y * scaleY, 3, 0, Math.PI * 2);
    ctx.fill();
  }
}
</script>

</body>
</html>
